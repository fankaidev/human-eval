{"task_id": "HumanEval/0", "prompt": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n", "completion": "\n    # Use itertools.combinations to generate all pairs of numbers\n    pairs = itertools.combinations(numbers, 2)\n    \n    # Use a list comprehension to check each pair\n    # The 'if' condition in the list comprehension checks if the difference between any two numbers in the pair is less than the threshold\n    return any(abs(pair[0] - pair[1]) < threshold for pair in pairs)\n    "}
{"task_id": "HumanEval/1", "prompt": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n", "completion": "\n    # Find all groups of balanced parentheses within the input string\n    groups = re.findall(r'\\([^()]+\\)', paren_string.replace(' ', ''))\n    \n    # Return the list of groups\n    return groups\n    "}
{"task_id": "HumanEval/2", "prompt": "\n\ndef truncate_number(number: float) -> float:\n    \"\"\" Given a positive floating point number, it can be decomposed into\n    and integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n", "completion": "\n\nWe can use the modulo operator (`%`) to get the decimal part of a number. The modulo operator returns the remainder of the division of the number before it by the number after it. We can use the `math.floor` function to get the largest integer smaller than the given number and then subtract that from the original number to get the decimal part.\n\nHere's the completed function:\n\n```python\nimport math\n\ndef truncate_number(number: float) -> float:\n    \"\"\" Given a positive floating point number, it can be decomposed into\n    and integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n    # Calculate the smallest integer not greater than the input number\n    integer_part = math.floor(number)\n    \n    # Subtract the integer part from the number to get the decimal part\n    decimal_part = number - integer_part\n    \n    return decimal_part\n```\n\n"}
{"task_id": "HumanEval/3", "prompt": "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" You're given a list of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return True. Otherwise it should return False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"\n", "completion": "\n    balance = 0\n    for operation in operations:\n        balance += operation\n        if balance < 0:\n            return True\n    return False\n### end of completion\n```\n\nIn this solution, we initialize the balance to 0. We then iterate through the operations, adding each operation to the balance. If the balance ever falls below 0, we immediately return True. If we finish iterating through all operations and the balance is still not below 0, we return False."}
{"task_id": "HumanEval/4", "prompt": "from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n", "completion": "\n\n# First, calculate the mean of the input list\nmean_value = sum(numbers) / len(numbers)\n# Then, calculate the absolute difference between each number and the mean\nabs_diffs = [abs(num - mean_value) for num in numbers]\n# Finally, return the average of these absolute differences\nreturn sum(abs_diffs) / len(abs_diffs)\n```\n\n## output\n```python\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    ### start of completion\n\n# First, calculate the mean of the input list\nmean_value = sum(numbers) / len(numbers)\n# Then, calculate the absolute difference between each number and the mean\nabs_diffs = [abs(num - mean_value) for num in numbers]\n# Finally, return the average of these absolute differences\nreturn sum(abs_diffs) / len(abs_diffs)\n"}
{"task_id": "HumanEval/5", "prompt": "from typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\n", "completion": "\n```python\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\n\n    result = []\n    for i, num in enumerate(numbers):\n        if i > 0:\n            result.append(delimeter)\n        result.append(num)\n    return result\n"}
{"task_id": "HumanEval/6", "prompt": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n", "completion": "\n    groups = paren_string.split()  # split the string into separate groups\n    results = []  # initialize a list to store the results\n\n    for group in groups:\n        max_depth = 0  # initialize max_depth to 0\n        current_depth = 0  # initialize current_depth to 0\n\n        for char in group:  # iterate through each character in the group\n            if char == '(':  # if the character is an opening parenthesis\n                current_depth += 1  # increase current_depth\n                max_depth = max(max_depth, current_depth)  # update max_depth if necessary\n            elif char == ')':  # if the character is a closing parenthesis\n                current_depth -= 1  # decrease current_depth\n\n        results.append(max_depth)  # append max_depth to results\n\n    return results\n\n"}
{"task_id": "HumanEval/7", "prompt": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n", "completion": "\n\n```python\nfrom typing import List\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n\n    "}
{"task_id": "HumanEval/8", "prompt": "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n", "completion": "\n\n```python\nfrom typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n    \n    # Initialize sum to 0 and product to 1\n    total_sum = 0\n    total_product = 1\n    \n    # Iterate over each number in the input list\n    for num in numbers:\n        # Add the current number to the total sum\n        total_sum += num\n        \n        # Multiply the current number with the total product\n        total_product *= num\n    \n    # Return the sum and product as a tuple\n    return total_sum, total_product\n\n"}
{"task_id": "HumanEval/9", "prompt": "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n", "completion": "\n\nWe will solve this problem by initializing a list to store our results and a variable to keep track of the current maximum. We'll then iterate over the input list, updating our maximum and result list accordingly.\n\n```python\nfrom typing import List\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    ### start of completion\n    \n    if not numbers:  # Check if the input list is empty\n        return []\n    \n    # Initialize a list to store the rolling maximum and a variable to keep track of the current maximum\n    result = [numbers[0]]\n    max_until_now = numbers[0]\n    \n    "}
{"task_id": "HumanEval/10", "prompt": "\n\ndef is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"\n", "completion": "\n\n```python\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"\n\n    rev_str = string[::-1]\n    for i in range(len(string) + 1):\n        postfix = string[i:]\n        if postfix == postfix[::-1]:  # Check if postfix is a palindrome\n            prefix_rev = rev_str[:len(string) - i]  # Reverse of prefix that comes before the palindromic suffix\n            palindrome = postfix + prefix_rev\n            return palindrome\n    return string + rev_str  # If no palindrome is found, return the original string with its reverse appended\n\n"}
{"task_id": "HumanEval/11", "prompt": "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n", "completion": "\n\n```python\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n    \n    # Initialize an empty string to store the result\n    result = \"\"\n    \n    # Iterate over the characters in the input strings\n    for i in range(min(len(a), len(b))):\n        # Perform XOR operation on corresponding bits and append the result\n        result += str(int(a[i]) ^ int(b[i]))\n    \n    # If one of the input strings is longer than the other, append the remaining bits\n    result += a[len(b):] if len(a) > len(b) else b[len(a):]\n    \n    return result\n\n"}
{"task_id": "HumanEval/12", "prompt": "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n", "completion": "\n    if not strings:\n        return None  # Return None if the list is empty\n    longest_str = strings[0]  # Initialize longest_str with the first string in the list\n    for s in strings:\n        if len(s) > len(longest_str):  # If a longer string is found\n            longest_str = s  # Update longest_str to be that string\n    return longest_str  # Return the longest string\n    "}
{"task_id": "HumanEval/13", "prompt": "\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n", "completion": "\n    # Using Euclid's algorithm, if b is zero, a is the GCD\n    if b == 0:\n        return a\n    else:\n        # Otherwise, replace a with b and b with the remainder of a divided by b\n        return greatest_common_divisor(b, a % b)\n```\n\nThis function uses the Euclidean algorithm to find the greatest common divisor (GCD) of two integers 'a' and 'b'. The Euclidean algorithm states that the GCD of 'a' and 'b' is the same as the GCD of 'b' and the remainder of 'a' divided by 'b'. This process is repeated until 'b' is zero, at which point 'a' is the GCD. This algorithm works by recursively replacing 'a' with 'b' and 'b' with the remainder of 'a' divided by 'b' until the base case is reached. \n\nHere is an explanation of the function:\n\n- It accepts two arguments, 'a' and 'b', which are the two integers for which the GCD needs to be found.\n- It checks if 'b' is zero. If it is, then 'a' is the GCD, because there is no remainder when 'a' is divided by zero (in the context of the Euclidean algorithm).\n- If 'b' is not zero, it calls itself with 'b' and the remainder of 'a' divided by 'b', effectively applying the Euclidean algorithm recursively.\n\nThis is a very efficient and simple way to find the GCD, with a time complexity of O(log min(a, b)), making it a great choice for most use cases."}
{"task_id": "HumanEval/14", "prompt": "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\"\n", "completion": "\n\n```python\nfrom typing import List\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\"\n    # Initialize an empty list to store prefixes\n    prefixes = []\n    \n    # Iterate over the length of the string\n    for length in range(1, len(string) + 1):\n        # For each length, extract the prefix using string slicing\n        prefix = string[:length]\n        \n        # Append the prefix to the list\n        prefixes.append(prefix)\n    \n    # Return the list of prefixes in the order they were generated\n    return prefixes\n"}
